module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/slvn/Desktop/modules/botpress-broadcast";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _botpress = __webpack_require__(2);
	
	var _botpressVersionManager = __webpack_require__(3);
	
	var _botpressVersionManager2 = _interopRequireDefault(_botpressVersionManager);
	
	var _deamon = __webpack_require__(4);
	
	var _deamon2 = _interopRequireDefault(_deamon);
	
	var _db = __webpack_require__(9);
	
	var _db2 = _interopRequireDefault(_db);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var db = null;
	var knex = null;
	
	module.exports = {
	  init: function init(bp) {
	    (0, _botpressVersionManager2.default)(bp, __dirname);
	    (0, _deamon2.default)(bp);
	    bp.db.get().then(function (_knex) {
	      knex = _knex;
	      db = (0, _db2.default)(knex);
	    });
	  },
	  ready: function ready(bp) {
	
	    var router = bp.getRouter('botpress-broadcast');
	
	    router.get('/broadcasts', function (req, res, next) {
	      db.listSchedules().then(function (rows) {
	        var broadcasts = rows.map(function (row) {
	          var _row$date_time$split = row.date_time.split(' '),
	              _row$date_time$split2 = _slicedToArray(_row$date_time$split, 2),
	              date = _row$date_time$split2[0],
	              time = _row$date_time$split2[1];
	
	          var progress = row.total_count ? row.sent_count / row.total_count : (0, _botpress.DatabaseHelpers)(knex).bool.parse(row.outboxed) ? 1 : 0;
	
	          return {
	            type: row.type,
	            content: row.text,
	            outboxed: (0, _botpress.DatabaseHelpers)(knex).bool.parse(row.outboxed),
	            errored: (0, _botpress.DatabaseHelpers)(knex).bool.parse(row.errored),
	            progress: progress,
	            userTimezone: !row.ts,
	            date: date,
	            time: time,
	            id: row.id,
	            filteringConditions: row.filters && JSON.parse(row.filters)
	          };
	        });
	
	        res.send(broadcasts);
	      });
	    });
	
	    router.put('/broadcasts', function (req, res, next) {
	      var _req$body = req.body,
	          date = _req$body.date,
	          time = _req$body.time,
	          timezone = _req$body.timezone,
	          content = _req$body.content,
	          type = _req$body.type,
	          filters = _req$body.filters;
	
	      db.addSchedule({ date: date, time: time, timezone: timezone, content: content, type: type, filters: filters }).then(function (id) {
	        return res.send({ id: id });
	      });
	    });
	
	    router.post('/broadcasts', function (req, res, next) {
	      var _req$body2 = req.body,
	          id = _req$body2.id,
	          date = _req$body2.date,
	          time = _req$body2.time,
	          timezone = _req$body2.timezone,
	          content = _req$body2.content,
	          type = _req$body2.type,
	          filters = _req$body2.filters;
	
	      db.updateSchedule({ id: id, date: date, time: time, timezone: timezone, content: content, type: type, filters: filters }).then(function () {
	        return res.sendStatus(200);
	      }).catch(function (err) {
	        res.status(500).send({ message: err.message });
	      });
	    });
	
	    router.delete('/broadcasts/:id', function (req, res, next) {
	      db.deleteSchedule(req.params.id).then(function () {
	        res.sendStatus(200);
	      }).catch(function (err) {
	        res.status(500).send({ message: err.message });
	      });
	    });
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("botpress");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("botpress-version-manager");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _botpress = __webpack_require__(2);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _bluebird = __webpack_require__(6);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _bluebirdRetry = __webpack_require__(7);
	
	var _bluebirdRetry2 = _interopRequireDefault(_bluebirdRetry);
	
	var _lodash = __webpack_require__(8);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _db = __webpack_require__(9);
	
	var _db2 = _interopRequireDefault(_db);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var knex = null;
	var bp = null;
	
	var schedulingLock = false;
	var sendingLock = false;
	
	var INTERVAL_BASE = 10 * 1000;
	var SCHEDULE_TO_OUTBOX_INTERVAL = INTERVAL_BASE * 1;
	var SEND_BROADCAST_INTERVAL = INTERVAL_BASE * 1;
	
	var emitChanged = _lodash2.default.throttle(function () {
	  bp && bp.events.emit('broadcast.changed');
	}, 1000);
	
	function padDigits(number, digits) {
	  return Array(Math.max(digits - String(number).length + 1, 0)).join(0) + number;
	}
	
	function scheduleToOutbox() {
	  if (!knex || schedulingLock) {
	    return;
	  }
	
	  var inFiveMinutes = (0, _moment2.default)().add(5, 'minutes').toDate();
	  var endOfDay = (0, _moment2.default)(inFiveMinutes).add(14, 'hours').toDate();
	
	  var upcomingFixedTime = (0, _botpress.DatabaseHelpers)(knex).date.isAfter(inFiveMinutes, 'ts');
	  var upcomingVariableTime = (0, _botpress.DatabaseHelpers)(knex).date.isAfter(endOfDay, 'date_time');
	
	  schedulingLock = true;
	
	  return knex('broadcast_schedules').where({
	    outboxed: (0, _botpress.DatabaseHelpers)(knex).bool.false()
	  }).andWhere(function () {
	    this.where(function () {
	      this.whereNotNull('ts').andWhere(upcomingFixedTime);
	    }).orWhere(function () {
	      this.whereNull('ts').andWhere(upcomingVariableTime);
	    });
	  }).then(function (schedules) {
	    return _bluebird2.default.map(schedules, function (schedule) {
	      return knex('users').distinct('timezone').select().then(function (timezones) {
	        return _bluebird2.default.mapSeries(timezones, function (_ref) {
	          var tz = _ref.timezone;
	
	          var initialTz = tz;
	          var sign = Number(tz) >= 0 ? '+' : '-';
	          tz = padDigits(Math.abs(Number(tz)), 2);
	          var relTime = (0, _moment2.default)('' + schedule.date_time + sign + tz, 'YYYY-MM-DD HH:mmZ').toDate();
	          var adjustedTime = (0, _botpress.DatabaseHelpers)(knex).date.format(schedule.ts ? schedule.ts : relTime);
	
	          var whereClause = _lodash2.default.isNil(initialTz) ? 'where timezone IS NULL' : 'where timezone = :initialTz';
	
	          var sql = 'insert into broadcast_outbox ("userId", "scheduleId", "ts")\n            select userId, :scheduleId, :adjustedTime\n            from (\n              select id as userId\n              from users\n              ' + whereClause + '\n            ) as q1';
	
	          return knex.raw(sql, {
	            scheduleId: schedule.id,
	            adjustedTime: adjustedTime,
	            initialTz: initialTz
	          }).then();
	        });
	      }).then(function () {
	        return knex('broadcast_outbox').where({ scheduleId: schedule.id }).select(knex.raw('count(*) as count')).then().get(0).then(function (_ref2) {
	          var count = _ref2.count;
	
	          return knex('broadcast_schedules').where({ id: schedule.id }).update({
	            outboxed: (0, _botpress.DatabaseHelpers)(knex).bool.true(),
	            total_count: count
	          }).then(function () {
	            bp.logger.info('[broadcast] Scheduled broadcast #' + schedule.id, '. [' + count + ' messages]');
	
	            if (schedule.filters && JSON.parse(schedule.filters).length > 0) {
	              bp.logger.info('[broadcast] Filters found on broadcast #' + schedule.id, '. Filters are applied at sending time.');
	            }
	
	            emitChanged();
	          });
	        });
	      });
	    });
	  }).finally(function () {
	    schedulingLock = false;
	  });
	}
	
	var _sendBroadcast = _bluebird2.default.method(function (row) {
	  var dropPromise = _bluebird2.default.resolve(false);
	
	  if (row.filters) {
	    dropPromise = _bluebird2.default.mapSeries(JSON.parse(row.filters), function (filter) {
	      var fnBody = filter.trim();
	      if (!/^return /i.test(fnBody)) {
	        fnBody = 'return ' + fnBody;
	      }
	
	      var fn = new Function('bp', 'userId', 'platform', fnBody);
	      return _bluebird2.default.method(fn)(bp, row.userId, row.platform);
	    }).then(function (values) {
	      return _lodash2.default.some(values, function (v) {
	        if (v !== true && v !== false) {
	          bp.logger.warn('[broadcast] Filter returned something other ' + 'than a boolean (or a Promise of a boolean)');
	        }
	
	        return typeof v !== 'undefined' && v !== null && v !== true;
	      });
	    });
	  }
	
	  return dropPromise.then(function (drop) {
	    if (drop) {
	      bp.logger.debug('[broadcast] Drop sending #' + row.scheduleId + ' to user: ' + row.userId + '. Reason = Filters');
	      return;
	    }
	
	    console.log(row);
	    if (row.type === 'text') {
	      bp.middlewares.sendOutgoing({
	        platform: row.platform,
	        type: 'text',
	        text: row.text,
	        raw: {
	          to: row.userId,
	          message: row.text
	        },
	        user: {
	          id: row.userId
	        }
	      });
	    } else {
	      var fn = new Function('bp', 'userId', 'platform', row.text);
	      return fn(bp, row.userId, row.platform);
	    }
	  });
	});
	
	function sendBroadcasts() {
	  if (!knex || sendingLock) {
	    return;
	  }
	
	  sendingLock = true;
	
	  var isPast = (0, _botpress.DatabaseHelpers)(knex).date.isBefore(knex.raw('"broadcast_outbox"."ts"'), (0, _botpress.DatabaseHelpers)(knex).date.now());
	
	  knex('broadcast_outbox').where(isPast).join('users', 'users.id', 'broadcast_outbox.userId').join('broadcast_schedules', 'scheduleId', 'broadcast_schedules.id').limit(1000).select(['users.userId as userId', 'users.platform as platform', 'broadcast_schedules.text as text', 'broadcast_schedules.type as type', 'broadcast_schedules.id as scheduleId', 'broadcast_schedules.filters as filters', 'broadcast_outbox.ts as sendTime', 'broadcast_outbox.userId as scheduleUser']).then(function (rows) {
	    var abort = false;
	    return _bluebird2.default.mapSeries(rows, function (row) {
	      if (abort) {
	        return;
	      }
	      return (0, _bluebirdRetry2.default)(function () {
	        return _sendBroadcast(row);
	      }, {
	        max_tries: 3,
	        interval: 1000,
	        backoff: 3
	      }).then(function () {
	        return knex('broadcast_outbox').where({ userId: row.scheduleUser, scheduleId: row.scheduleId }).delete().then(function () {
	          return knex('broadcast_schedules').where({ id: row.scheduleId }).update({ sent_count: knex.raw('sent_count + 1') }).then(function () {
	            return emitChanged();
	          });
	        });
	      }).catch(function (err) {
	        abort = true;
	
	        bp.logger.error('[broadcast] Broadcast #' + row.scheduleId + ' failed. Broadcast aborted. Reason: ' + err.message);
	
	        bp.notifications.send({
	          level: 'error',
	          message: 'Broadcast #' + row.scheduleId + ' failed.' + ' Please check logs for the reason why.',
	          url: '/logs'
	        });
	
	        return knex('broadcast_schedules').where({ id: row.scheduleId }).update({
	          errored: (0, _botpress.DatabaseHelpers)(knex).bool.true()
	        }).then(function () {
	          return knex('broadcast_outbox').where({ scheduleId: row.scheduleId }).delete().then(function () {
	            return emitChanged();
	          });
	        });
	      });
	    });
	  }).finally(function () {
	    sendingLock = false;
	  });
	}
	
	module.exports = function (botpress) {
	  bp = botpress;
	
	  bp.db.get().then(function (k) {
	    var _DB = (0, _db2.default)(k),
	        initialize = _DB.initialize;
	
	    knex = k;
	    initialize();
	  });
	
	  setInterval(scheduleToOutbox, SCHEDULE_TO_OUTBOX_INTERVAL);
	  setInterval(sendBroadcasts, SEND_BROADCAST_INTERVAL);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("moment");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("bluebird");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("bluebird-retry");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _botpress = __webpack_require__(2);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var knex = null;
	
	function initialize() {
	  if (!knex) {
	    throw new Error('you must initialize the database before');
	  }
	
	  return (0, _botpress.DatabaseHelpers)(knex).createTableIfNotExists('broadcast_schedules', function (table) {
	    table.increments('id').primary();
	    table.string('date_time');
	    table.timestamp('ts');
	    table.string('text');
	    table.string('type');
	    table.boolean('outboxed');
	    table.boolean('errored');
	    table.integer('total_count');
	    table.integer('sent_count');
	    table.timestamp('created_on');
	    table.string('filters');
	  }).then(function () {
	    return (0, _botpress.DatabaseHelpers)(knex).createTableIfNotExists('broadcast_outbox', function (table) {
	      table.integer('scheduleId').references('broadcast_schedules.id').onDelete('CASCADE');
	      table.string('userId').references('users.id');
	      table.primary(['scheduleId', 'userId']);
	      table.timestamp('ts');
	    });
	  });
	}
	
	function addSchedule(_ref) {
	  var date = _ref.date,
	      time = _ref.time,
	      timezone = _ref.timezone,
	      content = _ref.content,
	      type = _ref.type,
	      filters = _ref.filters;
	
	  var dateTime = date + ' ' + time;
	  var ts = null;
	
	  if (timezone) {
	    ts = (0, _moment2.default)(new Date(dateTime + ' ' + timezone)).toDate();
	  }
	
	  var row = {
	    date_time: dateTime,
	    ts: ts ? (0, _botpress.DatabaseHelpers)(knex).date.format(ts) : null,
	    text: content,
	    type: type,
	    outboxed: false,
	    errored: false,
	    total_count: 0,
	    sent_count: 0,
	    created_on: (0, _botpress.DatabaseHelpers)(knex).date.now(),
	    filters: JSON.stringify(filters)
	  };
	
	  return knex('broadcast_schedules').insert(row, 'id').then().get(0);
	}
	
	function updateSchedule(_ref2) {
	  var id = _ref2.id,
	      date = _ref2.date,
	      time = _ref2.time,
	      timezone = _ref2.timezone,
	      content = _ref2.content,
	      type = _ref2.type,
	      filters = _ref2.filters;
	
	  var dateTime = date + ' ' + time;
	  var ts = null;
	  if (timezone) {
	    ts = (0, _moment2.default)(new Date(dateTime + ' ' + timezone)).toDate();
	  }
	
	  var row = {
	    date_time: dateTime,
	    ts: (0, _botpress.DatabaseHelpers)(knex).date.format(ts),
	    text: content,
	    type: type,
	    filters: JSON.stringify(filters)
	  };
	
	  return knex('broadcast_schedules').where({
	    id: id,
	    outboxed: (0, _botpress.DatabaseHelpers)(knex).bool.false()
	  }).update(row).then();
	}
	
	function deleteSchedule(id) {
	  return knex('broadcast_schedules').where({ id: id }).delete().then(function () {
	    return knex('broadcast_outbox').where({ scheduleId: id }).del().then(function () {
	      return true;
	    });
	  });
	}
	
	function listSchedules() {
	  return knex('broadcast_schedules').then();
	}
	
	module.exports = function (k) {
	  knex = k;
	  return { initialize: initialize, addSchedule: addSchedule, deleteSchedule: deleteSchedule, updateSchedule: updateSchedule, listSchedules: listSchedules };
	};

/***/ }
/******/ ]);
//# sourceMappingURL=node.bundle.js.map