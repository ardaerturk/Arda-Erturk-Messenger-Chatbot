module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/slvn/Desktop/botpress-subscription";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _botpressVersionManager = __webpack_require__(2);
	
	var _botpressVersionManager2 = _interopRequireDefault(_botpressVersionManager);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(4);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _lodash = __webpack_require__(5);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _db = __webpack_require__(6);
	
	var _db2 = _interopRequireDefault(_db);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var subscriptions = null;
	var cached_config = null;
	
	var incomingMiddleware = function incomingMiddleware(bp) {
	  return function (event, next) {
	    if (!subscriptions || !cached_config) {
	      return next();
	    }
	
	    var categoriesText = subscriptions.map(function (s) {
	      return s.category.toUpperCase();
	    }).join(', ');
	
	    var executeAction = function executeAction(type, action) {
	      if (type === 'text') {
	        var txt = action.replace(/{{categories}}/ig, categoriesText);
	
	        bp.middlewares.sendOutgoing({
	          platform: event.platform,
	          type: 'text',
	          text: txt,
	          raw: {
	            to: event.user && event.user.id,
	            message: txt
	          }
	        });
	      } else {
	        var fn = new Function('bp', 'event', 'userId', 'platform', action);
	        fn(bp, event, event.user.id, event.platform);
	      }
	    };
	
	    if (cached_config && _lodash2.default.includes(cached_config.manage_keywords, event.text)) {
	      return executeAction(cached_config.manage_type, cached_config.manage_action);
	    }
	
	    if (subscriptions) {
	      var exit = false;
	      subscriptions.forEach(function (sub) {
	        if (_lodash2.default.includes(sub.sub_keywords, event.text)) {
	          exit = true;
	          (0, _db2.default)(bp).subscribe(event.platform + ':' + event.user.id, sub.category).then(function () {
	            executeAction(sub.sub_action_type, sub.sub_action);
	          }).catch(next);
	        }
	
	        if (_lodash2.default.includes(sub.unsub_keywords, event.text)) {
	          exit = true;
	          (0, _db2.default)(bp).unsubscribe(event.platform + ':' + event.user.id, sub.category).then(function () {
	            executeAction(sub.unsub_action_type, sub.unsub_action);
	          }).catch(next);
	        }
	      });
	      if (exit) {
	        return;
	      }
	    }
	
	    next();
	  };
	};
	
	module.exports = {
	
	  config: {
	    manage_keywords: { type: 'any', required: true, default: ['MANAGE_SUBSCRIPTIONS'], validation: function validation(v) {
	        return _lodash2.default.isArray(v);
	      } },
	    manage_action: { type: 'string', required: true, default: 'To unsubscribe, type: UNSUBSCRIBE_<CATEGORY>. Categories are: {{categories}}' },
	    manage_type: { type: 'choice', required: true, default: 'text', validation: ['text', 'javascript'] }
	  },
	
	  init: function init(bp, config) {
	    (0, _botpressVersionManager2.default)(bp, __dirname);
	
	    bp.middlewares.register({
	      name: 'manage.subscriptions',
	      type: 'incoming',
	      handler: incomingMiddleware(bp),
	      order: 15,
	      module: 'botpress-subscription',
	      description: 'Subscribes and unsubscribes users to the defined Subscriptions.'
	    });
	
	    bp.subscription = {
	      subscribe: (0, _db2.default)(bp).subscribe,
	      unsubscribe: (0, _db2.default)(bp).unsubscribe,
	      isSubscribed: (0, _db2.default)(bp).isSubscribed,
	      getSubscribed: (0, _db2.default)(bp).getSubscribed
	    };
	
	    (0, _db2.default)(bp).bootstrap().then((0, _db2.default)(bp).listAll).then(function (subs) {
	      return subscriptions = subs;
	    });
	
	    config.loadAll().then(function (c) {
	      return cached_config = c;
	    });
	  },
	
	  ready: function ready(bp, config) {
	    var router = bp.getRouter('botpress-subscription');
	
	    var updateSubs = function updateSubs() {
	      return (0, _db2.default)(bp).listAll().then(function (subs) {
	        return subscriptions = subs;
	      });
	    };
	
	    router.get('/config', function (req, res) {
	      config.loadAll().then(function (c) {
	        cached_config = c;
	        res.send(cached_config);
	      });
	    });
	
	    router.post('/config', function (req, res) {
	      config.saveAll(req.body).then(function () {
	        return config.loadAll();
	      }).then(function (c) {
	        return cached_config = c;
	      }).then(function () {
	        return res.sendStatus(200);
	      });
	    });
	
	    router.get('/subscriptions', function (req, res) {
	      (0, _db2.default)(bp).listAll().then(function (subs) {
	        return res.send(subs);
	      });
	    });
	
	    router.put('/subscriptions/:category', function (req, res) {
	      (0, _db2.default)(bp).create(req.params.category).then(function () {
	        return res.sendStatus(200);
	      }).then(updateSubs);
	    });
	
	    router.post('/subscriptions/:id', function (req, res) {
	      (0, _db2.default)(bp).modify(req.params.id, req.body).then(function () {
	        return res.sendStatus(200);
	      }).then(updateSubs);
	    });
	
	    router.delete('/subscriptions/:id', function (req, res) {
	      (0, _db2.default)(bp).delete(req.params.id).then(function () {
	        return res.sendStatus(200);
	      }).then(updateSubs);
	    });
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("botpress-version-manager");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _moment = __webpack_require__(7);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _lodash = __webpack_require__(5);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _botpress = __webpack_require__(8);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Validate = __webpack_require__(9);
	
	module.exports = function (bp) {
	  return {
	    bootstrap: function bootstrap() {
	      return bp.db.get().then(initialize);
	    },
	    listAll: function listAll() {
	      return bp.db.get().then(listAllSubscription);
	    },
	    create: function create(category) {
	      return bp.db.get().then(function (knex) {
	        return _create(knex, category);
	      });
	    },
	    modify: function modify(id, options) {
	      return bp.db.get().then(function (knex) {
	        return update(knex, id, options);
	      });
	    },
	    delete: function _delete(id) {
	      return bp.db.get().then(function (knex) {
	        return remove(knex, id);
	      });
	    },
	    subscribe: function subscribe(userId, category) {
	      return bp.db.get().then(function (knex) {
	        return _subscribe(knex, userId, category);
	      });
	    },
	    unsubscribe: function unsubscribe(userId, category) {
	      return bp.db.get().then(function (knex) {
	        return _unsubscribe(knex, userId, category);
	      });
	    },
	    isSubscribed: function isSubscribed(userId, category) {
	      return bp.db.get().then(function (knex) {
	        return _isSubscribed(knex, userId, category);
	      });
	    },
	    getSubscribed: function getSubscribed(userId) {
	      return bp.db.get().then(function (knex) {
	        return _getSubscribed(knex, userId);
	      });
	    }
	  };
	};
	
	function initialize(knex) {
	  return (0, _botpress.DatabaseHelpers)(knex).createTableIfNotExists('subscriptions', function (table) {
	    table.increments('id').primary();
	    table.timestamp('created_on');
	    table.string('category');
	    table.string('sub_keywords');
	    table.string('unsub_keywords');
	    table.string('sub_action');
	    table.string('unsub_action');
	    table.string('sub_action_type');
	    table.string('unsub_action_type');
	  }).then(function () {
	    return (0, _botpress.DatabaseHelpers)(knex).createTableIfNotExists('subscription_users', function (table) {
	      table.integer('subscriptionId').references('subscriptions.id');
	      table.string('userId').references('users.id');
	      table.primary(['subscriptionId', 'userId']);
	      table.timestamp('ts');
	    });
	  }).then(function () {
	    // Query compatible with SQLite3 & Postgres 9.5
	    return knex.schema.raw('create unique index\n      if not exists "subscriptions_category_unique" \n      on "subscriptions" ("category")').then();
	  });
	}
	
	function mapSubscriptions(subs) {
	  return subs.map(function (sub) {
	    sub.sub_keywords = JSON.parse(sub.sub_keywords);
	    sub.unsub_keywords = JSON.parse(sub.unsub_keywords);
	    return sub;
	  });
	}
	
	function listAllSubscription(knex) {
	  return knex('subscriptions').leftJoin('subscription_users', 'subscription_users.subscriptionId', 'subscriptions.id').groupBy('subscriptions.id').select(knex.raw('subscriptions.*, count("userId") as count')).then(mapSubscriptions);
	}
	
	function _create(knex, category) {
	  if (typeof category !== 'string' || category.length < 1) {
	    throw new Error('Category must be a valid string');
	  }
	
	  var upper = category.toUpperCase();
	
	  return knex('subscriptions').insert({
	    created_on: (0, _botpress.DatabaseHelpers)(knex).date.now(),
	    category: category,
	    sub_keywords: JSON.stringify(['SUBSCRIBE_' + upper]),
	    unsub_keywords: JSON.stringify(['UNSUBSCRIBE_' + upper]),
	    sub_action: 'Successfully subscribed to ' + category,
	    sub_action_type: 'text',
	    unsub_action: 'You are now unsubscribed from ' + category,
	    unsub_action_type: 'text'
	  });
	}
	
	function update(knex, id, options) {
	  options = validateOptions(options);
	
	  return knex('subscriptions').where('id', id).update({
	    category: options.category,
	    sub_keywords: JSON.stringify(options.sub_keywords),
	    unsub_keywords: JSON.stringify(options.unsub_keywords),
	    sub_action: options.sub_action,
	    sub_action_type: options.sub_action_type,
	    unsub_action: options.unsub_action,
	    unsub_action_type: options.unsub_action_type
	  });
	}
	
	function remove(knex, id) {
	  return knex('subscription_users').where('subscriptionId', id).del().then(function () {
	    return knex('subscriptions').where('id', id).del();
	  });
	}
	
	function _subscribe(knex, userId, category) {
	  return knex('subscriptions').where('category', category).then().get(0).then(function (sub) {
	    if (!sub) {
	      throw new Error('Could not find subscription of category: ' + category);
	    }
	
	    return knex('subscription_users').insert({
	      subscriptionId: sub.id,
	      userId: userId,
	      ts: (0, _botpress.DatabaseHelpers)(knex).date.now()
	    });
	  });
	}
	
	function _unsubscribe(knex, userId, category) {
	  return knex('subscriptions').where('category', category).then().get(0).then(function (sub) {
	    if (!sub) {
	      throw new Error('Could not find subscription of category: ' + category);
	    }
	
	    return knex('subscription_users').where({
	      subscriptionId: sub.id,
	      userId: userId
	    }).del();
	  });
	}
	
	function _isSubscribed(knex, userId, category) {
	  return _getSubscribed(knex, userId).then(function (subs) {
	    return _lodash2.default.includes(subs, category);
	  });
	}
	
	function _getSubscribed(knex, userId) {
	  return knex('subscription_users').join('subscriptions', 'subscriptions.id', 'subscription_users.subscriptionId').where({ userId: userId }).select('category').then(function (subs) {
	    return subs.map(function (s) {
	      return s.category;
	    });
	  });
	}
	
	function validateOptions(options) {
	  var args = Validate.named(options, {
	    category: 'string',
	    sub_keywords: 'array',
	    unsub_keywords: 'array',
	    sub_action: 'string',
	    unsub_action: 'string',
	    sub_action_type: 'string',
	    unsub_action_type: 'string'
	  });
	
	  if (!args.isValid()) {
	    throw args.errorString();
	  }
	
	  return _lodash2.default.pick(options, ['category', 'sub_keywords', 'unsub_keywords', 'sub_action', 'unsub_action', 'sub_action_type', 'unsub_action_type']);
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("moment");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("botpress");

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = require("validate-arguments");

/***/ }
/******/ ]);
//# sourceMappingURL=node.bundle.js.map